# -*- coding: utf-8 -*-
"""pass.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CjNp7kBjp6LB5Z-qkw1fz-AhSG3SG0K0
"""

!pip install cryptography

""" defines a function generate_password that creates a random password using letters, symbols, and numbers. It imports the random and string modules to access functions for random selection and predefined character sets like letters, digits, and punctuation. The function takes three arguments: the password length (default is 12), and two boolean flags that control whether to include symbols and numbers in the password (both default to True).

The function first initializes the characters pool with lowercase and uppercase English letters using string.ascii_letters. If include_symbols is True, it adds special characters like !@#$%^&* from string.punctuation to the pool. Similarly, if include_numbers is True, it adds numeric characters (0-9) using string.digits. The password is then generated by randomly selecting characters from this pool for the specified length. Each character is chosen using random.choice, and the resulting characters are combined into a single string. The example at the end demonstrates generating and printing a password with the default settings (12 characters long, including letters, symbols, and numbers).
"""

import random
import string

def generate_password(length=12, include_symbols=True, include_numbers=True):
    characters = string.ascii_letters
    if include_symbols:
        characters += string.punctuation
    if include_numbers:
        characters += string.digits

    return ''.join(random.choice(characters) for _ in range(length))

# Example usage
print(generate_password())

"""This Python script demonstrates how to securely encrypt and decrypt passwords using the cryptography library's Fernet module. First, it defines a function generate_key() that generates a new encryption key using Fernet.generate_key() and stores it in a file called secret.key. This key is required for both encryption and decryption and is stored securely. The load_key() function is used to load this key from the file.

The encrypt_password() function takes a plaintext password and the encryption key as inputs, encrypts the password using Fernet, and returns the encrypted password. The password is first converted to bytes using .encode() before encryption. The decrypt_password() function reverses this process: it takes the encrypted password and the key, decrypts the password, and converts it back to a readable string using .decode().

In the example, the key is generated and stored using generate_key() (run only once), and then loaded using load_key(). The password "mypassword" is encrypted and printed, followed by decrypting the encrypted version to verify that it can be successfully restored to its original form
"""

from cryptography.fernet import Fernet

# Generate and store a key (run only once to create the key)
def generate_key():
    key = Fernet.generate_key()
    with open("secret.key", "wb") as key_file:
        key_file.write(key)

# Load the encryption key
def load_key():
    return open("secret.key", "rb").read()

# Encrypt password
def encrypt_password(password, key):
    f = Fernet(key)
    encrypted_password = f.encrypt(password.encode())
    return encrypted_password

# Decrypt password
def decrypt_password(encrypted_password, key):
    f = Fernet(key)
    decrypted_password = f.decrypt(encrypted_password).decode()
    return decrypted_password

# Example usage
generate_key()  # Run this only once
key = load_key()

password = "mypassword"
encrypted_password = encrypt_password(password, key)
print("Encrypted:", encrypted_password)

decrypted_password = decrypt_password(encrypted_password, key)
print("Decrypted:", decrypted_password)

"""This Python code facilitates the secure storage and retrieval of encrypted passwords using a JSON file. The store_password function saves an encrypted password associated with a given service name into a passwords.json file. It first attempts to read existing passwords from the file, adds or updates the entry with the service name and encrypted password, and then writes the updated dictionary back to the file. If the file does not exist initially, it starts with an empty dictionary. The retrieve_password function retrieves the encrypted password for a specified service from passwords.json, decodes it from a string to bytes, and then decrypts it using a provided encryption key. Example usage includes storing an encrypted password under a service name and then retrieving and printing it by decrypting it with the same key."""

import json

def store_password(service_name, encrypted_password):
    passwords = {}
    try:
        with open("passwords.json", "r") as file:
            passwords = json.load(file)
    except FileNotFoundError:
        pass

    passwords[service_name] = encrypted_password.decode()

    with open("passwords.json", "w") as file:
        json.dump(passwords, file)

def retrieve_password(service_name, key):
    with open("passwords.json", "r") as file:
        passwords = json.load(file)

    encrypted_password = passwords[service_name].encode()
    return decrypt_password(encrypted_password, key)

# Example usage
store_password("github", encrypted_password)
print("Retrieved password:", retrieve_password("github", key))

""" defines a list_passwords function and a menu function to manage a simple password manager.

The list_passwords function reads the passwords.json file to display all stored passwords. It loads the file's content into a dictionary, iterates through the stored service names and encrypted passwords, and prints them. If the file does not exist, it outputs a message indicating that no passwords are found. If the file is empty, it informs the user that no passwords are stored yet.

The menu function provides an interactive command-line interface to manage passwords. It continuously presents a menu with options to generate, store, retrieve passwords, list all stored passwords, or exit. When generating a password, it prompts the user for the desired length and displays the generated password. For storing a password, it asks for the service name and password, encrypts the password, and saves it. For retrieving a password, it asks for the service name, decrypts the password, and displays it. The list_passwords function is called to show all stored passwords when selected. The menu continues to loop until the user chooses to exit by entering '5'. If an invalid option is chosen, it prompts the user to try again.
"""

def list_passwords():
    try:
        with open("passwords.json", "r") as file:
            passwords = json.load(file)
            if passwords:
                print("\nStored passwords:")
                for service, encrypted_password in passwords.items():
                    print(f"{service}: {encrypted_password}")
            else:
                print("No passwords stored yet.")
    except FileNotFoundError:
        print("No password file found.")

def menu():
    key = load_key()
    while True:
        print("\n1. Generate Password\n2. Store Password\n3. Retrieve Password\n4. List All Stored Passwords\n5. Exit")
        choice = input("Choose an option: ")

        if choice == '1':
            length = int(input("Enter password length: "))
            password = generate_password(length)
            print("Generated Password:", password)

        elif choice == '2':
            service = input("Enter the service name: ")
            password = input("Enter password: ")
            encrypted_password = encrypt_password(password, key)
            store_password(service, encrypted_password)
            print(f"Password stored for {service}.")

        elif choice == '3':
            service = input("Enter the service name: ")
            try:
                decrypted_password = retrieve_password(service, key)
                print(f"Password for {service}: {decrypted_password}")
            except KeyError:
                print(f"No password stored for {service}.")

        elif choice == '4':
            list_passwords()

        elif choice == '5':
            break
        else:
            print("Invalid choice. Try again.")

menu()